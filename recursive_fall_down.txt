0) W^(+): 5, 7, 9, 916, 001, 001+315, 116-9, 9*7, 110+9*7, 116*(10-5*7-31/8), ...
   W^(-): +6, u15, k, 3u, 001+, ... - запрещены!

G - начальный символ (от слова грамматика);

G ::= E, '\0' (грамматика сводится к числу, т.е. программа это число), '\0' (следующий символ после считанного символа равен '\0').
N ::= ['0'-'9']+ (число - это цифра от 0 до 9); в ' ' терминальные символы. + после ] - это неоднократное повторение правила подряд.
Если встречается символ от '0' до '9', то мы понимаем, что это цифра.
Мы можем определить: что есть цифра, что есть буква, что есть знак препинания, но не сможем определить, что есть программа. Важно определить программу.

E ::= N {['+', '-']N}*; // оператор * - повтор 0 или более раз.
T ::= P{['*', '/'']P}*;
P ::= '(' E ')'| N;

Строка, которую собираемся распознавать:

----------------------
| '3' | '\0' |   |   |
----------------------
^  N      ^
|-------->|

(за это
смещение
отвечает
правило
N)

Я предполагаю то, что я вижу соответствует правилу G. G сводится к правилу N. Поскольку мы перешли к правилу N, мы можем проверить, соответствует ли данному правилу текущий символ (т.е 3). Если соответствует, то мы передаем это правилу G и программа говорит, что все в порядке. 

Описанный абзац выше называется деревом синтаксического разбора.

Как распознается 3u ? (должно задетектиться и сказать, что это некорректные данные).

------------------------
| '3' | 'u' | '\0' |   |
------------------------
^  N     ^ G    ^   
|------->|----->|

N - распознает 3. Передает правилу G. G посчитает, что это правда, не обратив внимание на u.

Нужно добавить правило распознавание: элемент после цифры должны быть '\0'. К правилу G нужно добавить проверку на следующий элемент '\0'. Т.е правило G проверяет 2 варианта: проверка на то, что символ является цифрой; если символ - цифра, то проверяем, что следующим идёт '\0'.


Создадим глобальную переменную s, но ТОЛЬКО ОДНУ! Потом нужно зарефакторить и сделать переменной типа указателя.

const char * s = NULL;

int GetG (const char * str) {	// инициализация синтаксического разбора. GetG () - вызывается из main ();
	
	s = str;
	int val = GetN (); // синтаксическое правило транслируется через вызов функции. Все такие функции вызывают целые числа.
	assert ( * s == '\0');

	return val;
}

int GetN () { // GetN () получается всегда успешной. Эта штука пропустит синтаксическую ошибку.
	
	int val = 0;
	const char * sOld = s;

	if ('0' <= * s && * s <= '9') {

		val = (* s) - '0';
		s++;
	}

	assert (s > sOld); // т.е произошёл сдвиг.

	return val;
}



1) Многосимвольные числа без знака: пофиксим нулевую версию.

--------------------------
| '3' | '1' | '6' | '\0' |
--------------------------
^  N     ^ N    ^ N   ^
|------->|----->|---->|

Первый раз N проверяет символ на цифру. Если это так, то с этого момента повторяем вызов (делаем переход).

МЕНЯЕМ: 

int GetN () { // GetN () получается всегда успешной. Эта штука пропустит синтаксическую ошибку.
	
	int val = 0;
	const char * sOld = s;

	while ('0' <= * s && * s <= '9') {

		val = val * 10 + (* s) - '0';
		s++;
	}

	assert (s > sOld); // т.е произошёл сдвиг.

	return val;
}



2) Многосимвольные числа со знаком: 

--------------------------------------------------------------
| '1' | '2' | '3' | '-' | '2' | '3' | '+' | '1' | '0' | '\0' |
--------------------------------------------------------------
^  N     ^ N   ^ N   ^	E  ^ N   ^ N   ^ E   ^ N   ^ N   ^
|------->|---->|---->|---->|---->|---->|---->|---->|---->|

N считывает 1, 2, 3, а после встречает -. N передаёт для Е число 123. Е смотрит на -, считывает его, запоминает его и по новой вызывает N. По итогу N считывает 23 и после того, как встретит + , передает 23 для E, Е отнимает от 123 число 23 и держит уже 100, а после Е опять смотрит на + и только после этого вызывает N снова. По итогу мы будем держать в Е число 110, после этого N, Е встретят \0, но они не задетектят его. Этим должно заниматься G. 

int GetE () {
	
	int val = GetN ();

	whule ( *s == '+' || *s == '-') {

		char op = *s;
		s++;
		int val2 = GetN ();

		if (op == '+')
			val +=val2;

		else
			val -= val2;
	}

	return val;
}


3) Умножение и деление: 

--------------------------------------------------------------------------------------------------------------
| '1' | '2' | '3' | '-' | '2' | '3' | '0' | '/' | '1' | '0' | '+' | '2' | '0' | '*' | '2' | '+' | '1' | '\0' |
--------------------------------------------------------------------------------------------------------------
^  N     ^ N   ^ N   ^ E   ^ N   ^ N   ^ N   ^ N   ^ N   ^
|------->|---->|---->|---->|---->|---->|---->|---->|---->| 

(сфоткал на этом моменте).

Функция GetT пишется аналогично. GetT () вызывает внутри себя GetN (). Последовательный вызов получается.


int GetE () {
	
	int val = GetT ();

	whule ( *s == '+' || *s == '-') {

		char op = *s;
		s++;
		int val2 = GetT ();

		if (op == '+')
			val +=val2;

		else
			val -= val2;
	}

	return val;
} 


4) Скобки:

int GetP () {
	
	int val = 0;

	if ( *s == '(') {

		s++;
		val = GetE ();
		assert (*s == ')');
		s++;
	}

	else
		val = GetN ();

	return val;
}


------------------------------------------------------------------------------------------------------------------------
| '1' | '2' | '3' | '-' | '(' | '2' | '0' | '0' | '+' | '3' | '*' | '1' | '0' | ')' | '/' | '1' | '0' | '+' | '1' | '\0' 
------------------------------------------------------------------------------------------------------------------------