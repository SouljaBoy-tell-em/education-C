-------------------------------------------------------------------
Указатели! Довольно непростая тема (может быть даже самая сложная). 
-------------------------------------------------------------------



1. ВВЕДЕНИЕ

Когда мы создаём переменную, то помещаем её в какую-то ячейку памяти. Эта ячейка в памяти компьютера имеет некоторый адрес.
Адрес - это параметр, по которому можно найти переменную в памяти компьютера, подобно тому, как можно прийти в гости к человеку по адресу его проживания.
Чтобы узнать адрес переменной, можно воспользоваться операцией &. Т.е, если у нас есть переменная типа int, например, int n = 47, то можно определить адрес её
ячейки, в которой она находится следующим образом: &n.

Как вывести адрес переменной? - да так же, как и вывести число целочисленного типа. Только нужно использовать не спецификатор %d, а спецификатор %p:

printf ("n = %d, adress of n = %p", n, &n);

OUTPUT: n = 47, adress of n = 00000000006AFD4C


Указатель - это "новый" тип данных, куда можно записать адрес переменной, подобно любому типу данных. В предыдущем примере, я лишь показал операцию взятия
адреса и показал, что его можно вывести через функцию printf().

А что делать, если я хочу как-то работать с этой переменной? 
- Нужно сохранить адрес! 
- Но куда? 
- Создать переменную определенного типа, чтобы это сделать! 

А чтобы это сделать, нужно пользоваться следующей конструкцией:

(тип данных)* (название переменной) = &(переменная, адрес которой хотим сохранить, желательно того же типа);

Например:

int n = 47;
int* p;
*p = &n;

Можно было записать и короче:

int n = 47;
int* p = &n;

И в том, и в другом случаях мы сохранили адрес переменной n в переменную p, т.е. теперь p = 00000000006AFD4C и этим значением можно оперировать.
Ещё хочется сказать, что операция * также служит операцией разыменовывания. 
Что это значит? - это означает, что если мы имеем адрес некоторой переменной, то мы можем узнать, какое значение лежит по этому адресу.
Из приведённых выше примеров, знаем, что в переменной p хранится адрес переменной n. Создадим некоторую переменную m, в которую впоследствии запишем
значение переменной n (т.е 47). Приведём пример кода:

int n = 47, m;
int* p;
m = *p; 

В результате выполнения кода в переменную m будет записано значение n. Это всё в результате операции разыменовывания *.
Визуально это можно представить так:

p = &n (в p записан адрес переменной)
m = *p = *(&n) = (*&)n = n; // фактически *& "взаимоуничтожают" друг друга.

В результате выполнения следующей программы:

int n = 47, m;
int* p = &n;
m = *p;
printf ("n = %d, adress of n = %p, unadress = %d", n, p, m);

OUTPUT: n = 47, adress of n = 00000000006AFD40, unadress = 47

2. МАССИВЫ И УКАЗАТЕЛИ

Рассмотрим следующий фрагмент кода:

int arr[5] = {1, 3, 5, 4, 2}; 
int *pt, *pr; 
pt = &arr[0];
pr = arr;
printf ("arr[0] adress = %p, arr adress = %p", pt, pr);

OUTPUT: arr[0] adress = 00000000006AFD20, arr adress = 00000000006AFD20

Пояснение:
arr - массив, состоящий из 5 элементов.
pt, pr - указатели.
pt = &arr[0] - запись в указатель адреса первого элемента массива.
pr = arr - даёт тот же результат, как можно заметить после выполнения кода. Мы будем использовать для удобства второй вариант записи адреса первого элемента 
массива (т.е. pr = arr), ведь выглядит это солиднее. 

pr = arr назовем указателем на масиив arr. 

Вновь рассмотрим следующий код:

short dates[5];
double bills[5];
short* pti;
double* ptf;
pti = dates;
ptf = bills;
printf ("%23s %15s", "short", "double\n");
for (int i = 0; i < 5; i++)
  printf ("pointers + %d: %10p %10p\n", i, pti + i, ptf + i);
  
 OUTPUT: 
                   short         double
pointers + 0: 00000000006AFD20 00000000006AFCF0
pointers + 1: 00000000006AFD22 00000000006AFCF8
pointers + 2: 00000000006AFD24 00000000006AFD00
pointers + 3: 00000000006AFD26 00000000006AFD08
pointers + 4: 00000000006AFD28 00000000006AFD10

Пояснение:
dates, bills - массивы short и double, каждый из которых по 5 элементов, соответственно.
pti, ptf - указатели типов short и double, соответственно. 
pti = dates - указатель на массив dates.
ptf = bills - указатель на массив bills.
printf ("pointers + %d: %10p %10p\n", i, pti + i, ptf + i) - сначала выводит адреса на массивы dates и bills при i = 0. Но что происходит при увеличении
индекса? Видим, что в случае типа шорт, адрес меняется на 2 значения; в случае double - на 8 значений. Адрес меняется в зависимости от того, какой тип
данных получает указатель. 

Рассмотрим следующий код (дополнение к предыдущему):

short dates[5];
double bills[5];
short* pti;
double* ptf;
pti = dates;
ptf = bills;
printf ("%23s %15s ", "short", "double\n");
for (int i = 0; i < 5; i++)
  printf ("pointers + %d: %10p %10p\n", i, pti + i, ptf + i);

