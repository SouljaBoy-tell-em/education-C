-------------------------------------------------------------------
Указатели! Довольно непростая тема (может быть даже самая сложная). 
-------------------------------------------------------------------



1. ВВЕДЕНИЕ

Когда мы создаём переменную, то помещаем её в какую-то ячейку памяти. Эта ячейка в памяти компьютера имеет некоторый адрес.
Адрес - это параметр, по которому можно найти переменную в памяти компьютера, подобно тому, как можно прийти в гости к человеку по адресу его проживания.
Чтобы узнать адрес переменной, можно воспользоваться операцией &. Т.е, если у нас есть переменная типа int, например, int n = 47, то можно определить адрес её
ячейки, в которой она находится следующим образом: &n.

Как вывести адрес переменной? - да так же, как и вывести число целочисленного типа. Только нужно использовать не спецификатор %d, а спецификатор %p:

printf ("n = %d, adress of n = %p", n, &n);

OUTPUT: n = 47, adress of n = 00000000006AFD4C


Указатель - это "новый" тип данных, куда можно записать адрес переменной, подобно любому типу данных. В предыдущем примере, я лишь показал операцию взятия
адреса и показал, что его можно вывести через функцию printf().

А что делать, если я хочу как-то работать с этой переменной? 
- Нужно сохранить адрес! 
- Но куда? 
- Создать переменную определенного типа, чтобы это сделать! 

А чтобы это сделать, нужно пользоваться следующей конструкцией:

(тип данных)* (название переменной) = &(переменная, адрес которой хотим сохранить, желательно того же типа);

Например:

int n = 47;
int* p;
*p = &n;

Можно было записать и короче:

int n = 47;
int* p = &n;

И в том, и в другом случаях мы сохранили адрес переменной n в переменную p, т.е. теперь p = 00000000006AFD4C и этим значением можно оперировать.
Ещё хочется сказать, что операция * также служит операцией разыменовывания. 
Что это значит? - это означает, что если мы имеем адрес некоторой переменной, то мы можем узнать, какое значение лежит по этому адресу.
Из приведённых выше примеров, знаем, что в переменной p хранится адрес переменной n. Создадим некоторую переменную m, в которую впоследствии запишем
значение переменной n (т.е 47). Приведём пример кода:

int n = 47, m;
int* p;
m = *p; 

В результате выполнения кода в переменную m будет записано значение n. Это всё в результате операции разыменовывания *.
Визуально это можно представить так:

p = &n (в p записан адрес переменной)
m = *p = *(&n) = (*&)n = n; // фактически *& "взаимоуничтожают" друг друга.

В результате выполнения следующей программы:

int n = 47, m;
int* p = &n;
m = *p;
printf ("n = %d, adress of n = %p, unadress = %d", n, p, m);

OUTPUT: n = 47, adress of n = 00000000006AFD40, unadress = 47



2. МАССИВЫ И УКАЗАТЕЛИ

Рассмотрим следующий фрагмент кода:

int arr[5] = {1, 3, 5, 4, 2}; 
int *pt, *pr; 
pt = &arr[0];
pr = arr;
printf ("arr[0] adress = %p, arr adress = %p", pt, pr);

OUTPUT: arr[0] adress = 00000000006AFD20, arr adress = 00000000006AFD20

Пояснение:
arr - массив, состоящий из 5 элементов.
pt, pr - указатели.
pt = &arr[0] - запись в указатель адреса первого элемента массива.
pr = arr - даёт тот же результат, как можно заметить после выполнения кода. Мы будем использовать для удобства второй вариант записи адреса первого элемента 
массива (т.е. pr = arr), ведь выглядит это солиднее. 

pr = arr назовем указателем на масиив arr. 

Вновь рассмотрим следующий код:

short dates[5];
double bills[5];
short* pti;
double* ptf;
pti = dates;
ptf = bills;
printf ("%23s %15s", "short", "double\n");
for (int i = 0; i < 5; i++)
  printf ("pointers + %d: %10p %10p\n", i, pti + i, ptf + i);
  
 OUTPUT: 
                   short         double
pointers + 0: 00000000006AFD20 00000000006AFCF0
pointers + 1: 00000000006AFD22 00000000006AFCF8
pointers + 2: 00000000006AFD24 00000000006AFD00
pointers + 3: 00000000006AFD26 00000000006AFD08
pointers + 4: 00000000006AFD28 00000000006AFD10

Пояснение:
dates, bills - массивы short и double, каждый из которых по 5 элементов, соответственно.
pti, ptf - указатели типов short и double, соответственно. 
pti = dates - указатель на массив dates.
ptf = bills - указатель на массив bills.
printf ("pointers + %d: %10p %10p\n", i, pti + i, ptf + i) - сначала выводит адреса на массивы dates и bills при i = 0. Но что происходит при увеличении
индекса? Видим, что в случае типа шорт, адрес меняется на 2 значения; в случае double - на 8 значений. Адрес меняется в зависимости от того, какой тип
данных получает указатель. 

Рассмотрим следующий код (дополнение к предыдущему): добавлен третий столбец, в котором последовательно выводятся адреса на элементы массива bills.

short dates[5];
double bills[5];
short* pti;
double* ptf;
pti = dates;
ptf = bills;
printf ("%23s %18s %17s\n", "short", "double", "&arr[i]");
for (int i = 0; i < 5; i++)
	printf ("pointers + %d: %10p %10p %10p\n", i, pti + i, ptf + i, &bills[i]);
  
 OUTPUT: 
 
                   short             double           &arr[i]
pointers + 0: 00000000006AFD20 00000000006AFCF0 00000000006AFCF0
pointers + 1: 00000000006AFD22 00000000006AFCF8 00000000006AFCF8
pointers + 2: 00000000006AFD24 00000000006AFD00 00000000006AFD00
pointers + 3: 00000000006AFD26 00000000006AFD08 00000000006AFD08
pointers + 4: 00000000006AFD28 00000000006AFD10 00000000006AFD10

Как видим второй столбец массива в точности совпадает с третьим. Это значит, что при увеличении первого адресного элемента массива на единицу, получаем
адрес второго элемента массива; при увелечении на два - получаем адрес третьего и т.д. Значит можем утверждать следующее:

&bills[i] = ptf + i = bills + i = &bills[0] + i;
*(bills + i) = bills[i]; // операция разыменовывания введена аналогично операции разыменовывания для обычной переменной.

Т.е. значение i+1-го элемента массива можно определить следующим образом: double i_bills = *(bills + i);



3. ФУНКЦИИ, МАССИВЫ И УКАЗАТЕЛИ

Предположим, что мы хотим передать массив в функцию. Пусть имеем функцию Sum(). В неё мы хотим передать целочисленный массив, состоящий из 10 элементов arr[10].
Рассмотрим пример кода, который сделает всё понятным:

int Sum (int * ar);
int main (void) {

int arr[10] = {1, 3, 2, 13, 22, 21, 7, 8, 2, 47};
	
int sum = Sum (arr);
printf ("%d", sum);

}

int Sum (int* ar) {
	
int total = 0;
	
for (int i = 0; i < 10; i++)
	total += ar[i];
	
return total;
	
}

OUTPUT: 126

Пояснение: чтобы передать целочисленный массив в функцию Sum(), нужно в качестве аргумента функции взять указатель на первый элемент массива (int Sum (int * ar)).
Соответственно, в функции main() нужно передать в функцию Sum() первый элемент массива &arr[0] или просто arr (уже обсуждалось ранее, почему это одно и то же), т.е.
int sum = Sum(arr), где переменная sum - это переменная, которая получает возвращаемое значение функции Sum().



4. ИСПОЛЬЗОВАНИЕ ПАРАМЕТРОВ ТИПА УКАЗАТЕЛЕЙ (ОДИН ИЗ ПРИМЕРОВ)

Как уже отмечалось ранее при сложении адреса указателя с переменной какого-либо типа, адрес меняется. Приведу в пример код, который находит сумму элементов массива:

int sump (int * start, int * end);
int main (void) {

	int marbles[10] = {20, 10, 5, 39, 4, 16, 19, 26, 31, 20}, answer;
	answer = sump(marbles, marbles + 10);
	printf ("%d", answer);

}

int sump (int * start, int * end) {
	
	int total = 0;
	
	while (start < end) {
		
		total += *start;
		start++;
		
	}
	
	return total;
	
}

OUTPUT: 190

Пояснение: данный код принимает в функцию sump() и первый и последний адреса. В результате чего вычисляется сумма элементов массива marbles.
Аргументы start и end принимают адреса первого и последнего элементов массива. В переменную total последовательно инкрементируются элементы marbles через *start.
* стоит перед старт, чтобы разыменовать передаваемые адреса массива marbles. Перед каждым новым проходом циклапеременная start увеличивается 
(т.е. адрес start меняет свой адрес от первого элемента до последнего marbles). 



5. ОПЕРАЦИИ С УКАЗАТЕЛЯМИ

5.1. ПРИСВАИВАНИЕ УКАЗАТЕЛЮ АДРЕСА: с этим мы уже сталкивались. Создаём массив, создаём указатель, присваиваем указателю адрес элемента массива.

int arr[5];
int* pt;
pt = arr; // ну или pt = &arr[2], неважно.

5.2. 
