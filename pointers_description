-------------------------------------------------------------------
Указатели! Довольно непростая тема (может быть даже самая сложная). 
-------------------------------------------------------------------



1. ВВЕДЕНИЕ

Когда мы создаём переменную, то помещаем её в какую-то ячейку памяти. Эта ячейка в памяти компьютера имеет некоторый адрес.
Адрес - это параметр, по которому можно найти переменную в памяти компьютера, подобно тому, как можно прийти в гости к человеку по адресу его проживания.
Чтобы узнать адрес переменной, можно воспользоваться операцией &. Т.е, если у нас есть переменная типа int, например, int n = 47, то можно определить адрес её
ячейки, в которой она находится следующим образом: &n.

Как вывести адрес переменной? - да так же, как и вывести число целочисленного типа. Только нужно использовать не спецификатор %d, а спецификатор %p:

printf ("n = %d, adress of n = %p", n, &n);

OUTPUT: n = 47, adress of n = 00000000006AFD4C


Указатель - это "новый" тип данных, куда можно записать адрес переменной, подобно любому типу данных. В предыдущем примере, я лишь показал операцию взятия
адреса и показал, что его можно вывести через функцию printf().

А что делать, если я хочу как-то работать с этой переменной? 
- Нужно сохранить адрес! 
- Но куда? 
- Создать переменную определенного типа, чтобы это сделать! 

А чтобы это сделать, нужно пользоваться следующей конструкцией:

(тип данных)* (название переменной) = &(переменная, адрес которой хотим сохранить, желательно того же типа);

Например:

int n = 47;
int* p;
*p = &n;

Можно было записать и короче:

int n = 47;
int* p = &n;

И в том, и в другом случаях мы сохранили адрес переменной n в переменную p, т.е. теперь p = 00000000006AFD4C и этим значением можно оперировать.
Ещё хочется сказать, что операция * также служит операцией разыменовывания. 
Что это значит? - это означает, что если мы имеем адрес некоторой переменной, то мы можем узнать, какое значение лежит по этому адресу.
Из приведённых выше примеров, знаем, что в переменной p хранится адрес переменной n. Создадим некоторую переменную m, в которую впоследствии запишем
значение переменной n (т.е 47). Приведём пример кода:

int n = 47, m;
int* p;
m = *p; 

В результате выполнения кода в переменную m будет записано значение n. Это всё в результате операции разыменовывания *.
Визуально это можно представить так:

p = &n (в p записан адрес переменной)
m = *p = *(&n) = (*&)n = n; // фактически *& "взаимоуничтожают" друг друга.

В результате выполнения следующей программы:

int n = 47, m;
int* p = &n;
m = *p;
printf ("n = %d, adress of n = %p, unadress = %d", n, p, m);

OUTPUT: n = 47, adress of n = 00000000006AFD40, unadress = 47



2. МАССИВЫ И УКАЗАТЕЛИ

Рассмотрим следующий фрагмент кода:

int arr[5] = {1, 3, 5, 4, 2}; 
int *pt, *pr; 
pt = &arr[0];
pr = arr;
printf ("arr[0] adress = %p, arr adress = %p", pt, pr);

OUTPUT: arr[0] adress = 00000000006AFD20, arr adress = 00000000006AFD20

Пояснение:
arr - массив, состоящий из 5 элементов.
pt, pr - указатели.
pt = &arr[0] - запись в указатель адреса первого элемента массива.
pr = arr - даёт тот же результат, как можно заметить после выполнения кода. Мы будем использовать для удобства второй вариант записи адреса первого элемента 
массива (т.е. pr = arr), ведь выглядит это солиднее. 

pr = arr назовем указателем на масиив arr. 

Вновь рассмотрим следующий код:

short dates[5];
double bills[5];
short* pti;
double* ptf;
pti = dates;
ptf = bills;
printf ("%23s %15s", "short", "double\n");
for (int i = 0; i < 5; i++)
  printf ("pointers + %d: %10p %10p\n", i, pti + i, ptf + i);
  
 OUTPUT: 
                   short         double
pointers + 0: 00000000006AFD20 00000000006AFCF0
pointers + 1: 00000000006AFD22 00000000006AFCF8
pointers + 2: 00000000006AFD24 00000000006AFD00
pointers + 3: 00000000006AFD26 00000000006AFD08
pointers + 4: 00000000006AFD28 00000000006AFD10

Пояснение:
dates, bills - массивы short и double, каждый из которых по 5 элементов, соответственно.
pti, ptf - указатели типов short и double, соответственно. 
pti = dates - указатель на массив dates.
ptf = bills - указатель на массив bills.
printf ("pointers + %d: %10p %10p\n", i, pti + i, ptf + i) - сначала выводит адреса на массивы dates и bills при i = 0. Но что происходит при увеличении
индекса? Видим, что в случае типа шорт, адрес меняется на 2 значения; в случае double - на 8 значений. Адрес меняется в зависимости от того, какой тип
данных получает указатель. 

Рассмотрим следующий код (дополнение к предыдущему): добавлен третий столбец, в котором последовательно выводятся адреса на элементы массива bills.

short dates[5];
double bills[5];
short* pti;
double* ptf;
pti = dates;
ptf = bills;
printf ("%23s %18s %17s\n", "short", "double", "&arr[i]");
for (int i = 0; i < 5; i++)
	printf ("pointers + %d: %10p %10p %10p\n", i, pti + i, ptf + i, &bills[i]);
  
 OUTPUT: 
 
                   short             double           &arr[i]
pointers + 0: 00000000006AFD20 00000000006AFCF0 00000000006AFCF0
pointers + 1: 00000000006AFD22 00000000006AFCF8 00000000006AFCF8
pointers + 2: 00000000006AFD24 00000000006AFD00 00000000006AFD00
pointers + 3: 00000000006AFD26 00000000006AFD08 00000000006AFD08
pointers + 4: 00000000006AFD28 00000000006AFD10 00000000006AFD10

Как видим второй столбец массива в точности совпадает с третьим. Это значит, что при увеличении первого адресного элемента массива на единицу, получаем
адрес второго элемента массива; при увелечении на два - получаем адрес третьего и т.д. Значит можем утверждать следующее:

&bills[i] = ptf + i = bills + i = &bills[0] + i;
*(bills + i) = bills[i]; // операция разыменовывания введена аналогично операции разыменовывания для обычной переменной.

Т.е. значение i+1-го элемента массива можно определить следующим образом: double i_bills = *(bills + i);



3. ФУНКЦИИ, МАССИВЫ И УКАЗАТЕЛИ

Предположим, что мы хотим передать массив в функцию. Пусть имеем функцию Sum(). В неё мы хотим передать целочисленный массив, состоящий из 10 элементов arr[10].
Рассмотрим пример кода, который сделает всё понятным:

int Sum (int * ar);
int main (void) {

int arr[10] = {1, 3, 2, 13, 22, 21, 7, 8, 2, 47};
	
int sum = Sum (arr);
printf ("%d", sum);

}

int Sum (int* ar) {
	
int total = 0;
	
for (int i = 0; i < 10; i++)
	total += ar[i];
	
return total;
	
}

OUTPUT: 126

Пояснение: чтобы передать целочисленный массив в функцию Sum(), нужно в качестве аргумента функции взять указатель на первый элемент массива (int Sum (int * ar)).
Соответственно, в функции main() нужно передать в функцию Sum() первый элемент массива &arr[0] или просто arr (уже обсуждалось ранее, почему это одно и то же), т.е.
int sum = Sum(arr), где переменная sum - это переменная, которая получает возвращаемое значение функции Sum().



4. ИСПОЛЬЗОВАНИЕ ПАРАМЕТРОВ ТИПА УКАЗАТЕЛЕЙ (ОДИН ИЗ ПРИМЕРОВ)

Как уже отмечалось ранее при сложении адреса указателя с переменной какого-либо типа, адрес меняется. Приведу в пример код, который находит сумму элементов массива:

int sump (int * start, int * end);
int main (void) {

	int marbles[10] = {20, 10, 5, 39, 4, 16, 19, 26, 31, 20}, answer;
	answer = sump(marbles, marbles + 10);
	printf ("%d", answer);

}

int sump (int * start, int * end) {
	
	int total = 0;
	
	while (start < end) {
		
		total += *start;
		start++;
		
	}
	
	return total;
	
}

OUTPUT: 190

Пояснение: данный код принимает в функцию sump() и первый и последний адреса. В результате чего вычисляется сумма элементов массива marbles.
Аргументы start и end принимают адреса первого и последнего элементов массива. В переменную total последовательно инкрементируются элементы marbles через *start.
* стоит перед старт, чтобы разыменовать передаваемые адреса массива marbles. Перед каждым новым проходом циклапеременная start увеличивается 
(т.е. адрес start меняет свой адрес от первого элемента до последнего marbles). 



5. ОПЕРАЦИИ С УКАЗАТЕЛЯМИ

5.1. ПРИСВАИВАНИЕ УКАЗАТЕЛЮ АДРЕСА: с этим мы уже сталкивались. Создаём массив, создаём указатель, присваиваем указателю адрес элемента массива.

int arr[5];
int* pt;
pt = arr; // ну или pt = &arr[2], неважно.

5.2. РАЗЫМЕНОВЫВАНИЕ УКАЗАТЕЛЯ (ПОЛУЧЕНИЕ ЗНАЧЕНИЯ ПЕРЕМЕННОЙ): с этим мы тоже сталкивались. Имеется указатель, который хранит адрес

int arr[5];
int* pt;
pt = arr; // т.е. pt хранит адрес первого элемента массива
int n = *pt; // создали дополнительную переменную, в которую поместили указатель и разыменовали его посредством операции * (это уже было описано ранее).

5.3. АДРЕС УКАЗАТЕЛЯ: подобно тому, как указатель получает адрес какой-либо переменной, он сам имеет собственный адрес, на который может сослаться
другой указатель.

int n = 2;
int* pt = &n;
int** pr = &pt; // переменную pr называют указателем на указатель

5.4. ДОБАВЛЕНИЕ ПЕРЕМЕННОЙ К УКАЗАТЕЛЮ: пусть имеется указатель pr. При добавлении к нему некоторой переменных, его адрес изменится в зависимости от этой переменной.

int arr[5];
int* pt = arr, *pr;
pr = pt + 2; // pt =  00000000006AFCF0; pr = pt + 2 =  00000000006AFCF8. (тип int весит 4 байта. Он добавился 2 раза по 4 - получилось 8).

5.5. УКАЗАТЕЛИ МОЖНО СРАВНИВАТЬ: можно проверить на равенство адресов. Также была программа в пункте 4.



6. CONST В УКАЗАТЕЛЯХ

Если функция не задумывается о том, чтобы изменить массив, то используйте ключевое слово const. Хотите изменить массив - тогда не используйте const.

Прототип функции будет выглядеть, например, так: void (const int * ar); // понятно, что функция выглядит аналогично.

Теперь создадим следующий указатель на массив rates:
double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5};
const double * pt = rates; // pt принял адрес первого элемента данного массива
pt = &rates[2]; // присвоение указателю pt адреса третьего элемента массива. Так делать можно.
НЕЛЬЗЯ менять элемент массива через указатель, т.е. *pt = 47; - НЕДОПУСТИМО. Также НЕДОПУСТИМО *(pt + i) = 47 (и, соответственно, pt[i] = 47 - тоже НЕЛЬЗЯ).
Введём вспомогательный массив locked следующим образом:
const double locked[4] = {0.08, 0.075, 0.0725, 0.07};

Указателю на константу допускается присваивание адреса либо константных, либо неконстантных данных:
double rates [5] = {88.99, 100.12, 59.45, 183.11, 340.5};
const double locked[4] = {0.08, 0.075, 0.0725, 0.07};
const double * рс = rates; // допустимо
рс = locked; // допустимо
рс = &rates[3]; // допустимо

Тем не менее, обычным указателям могут быть присвоены только адреса неконстантных данных:
double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5};
const double locked[4] = {0.08, 0.075, 0.0725, 0.07};
double * pnc = rates; // допустимо
pnc = locked; // не допустимо
pnc = &rates[3]; // допустимо

Существуют и другие варианты использования const. К примеру, вы можете объявить
и инициализировать указатель таким образом, чтобы его нельзя было заставить
указывать на что-нибудь другое. Хитрость в том, где размещено ключевое слово
const:
double rates[5] = (88.99, 100.12, 59.45, 183.11, 340.5);
double * const рс = rates; // рс указывает на начало массива
рс = &rates[2]; // не разрешено указывать на что-нибудь другое
*рс = 92.99; // все в порядке -- изменяется rates[O]
Такой указатель можно по-прежнему применять для изменения значений, но он может
указывать только на ячейку, которая была присвоена первоначально.

Наконец, const можно использовать дважды, чтобы создать указатель, который не
допускает изменения ни адреса, куда он указывает, ни указываемого с помощью него
значения:
double rates[5] = (88.99, 100.12, 59.45, 183.11, 340.5);
const double * const рс = rates;
рс = &rates[2]; // не разрешено
рс = &rates [92.99]; // не разрешено

7. УКАЗАТЕЛИ И МНОГОМЕРНЫЕ МАССИВЫ:

Напомним, что создать двумерный масств можно следующим образом:
int zippo[4][3] = {{2, 4}, {6, 8}, {1, 3}, {5, 7}};

Получить адрес определенной элемента двумерным массивом можно также как и в случае переменной определенного типа. Для удобства создадим указатель
и поместим туда адрес произвольной переменной:
int *table;
table = &zippo[i][j];

Двумерный массив состоит из нескольких одномерных массивов. Каждый из этих одномерных массивов имеет адрес. Например, логические равенства имеют вид:
zippo[i] == &zippo[i][0];
zippo == &zippo[0]

