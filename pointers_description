-------------------------------------------------------------------
Указатели! Довольно непростая тема (может быть даже самая сложная). 
-------------------------------------------------------------------



1. ВВЕДЕНИЕ

Когда мы создаём переменную, то помещаем её в какую-то ячейку памяти. Эта ячейка в памяти компьютера имеет некоторый адрес.
Адрес - это параметр, по которому можно найти переменную в памяти компьютера, подобно тому, как можно прийти в гости к человеку по адресу его проживания.
Чтобы узнать адрес переменной, можно воспользоваться операцией &. Т.е, если у нас есть переменная типа int, например, int n = 47, то можно определить адрес её
ячейки, в которой она находится следующим образом: &n.

Как вывести адрес переменной? - да так же, как и вывести число целочисленного типа. Только нужно использовать не спецификатор %d, а спецификатор %p:

printf ("n = %d, adress of n = %p", n, &n);

OUTPUT: n = 47, adress of n = 00000000006AFD4C


Указатель - это "новый" тип данных, куда можно записать адрес переменной, подобно любому типу данных. В предыдущем примере, я лишь показал операцию взятия
адреса и показал, что его можно вывести через функцию printf().

А что делать, если я хочу как-то работать с этой переменной? 
- Нужно сохранить адрес! 
- Но куда? 
- Создать переменную определенного типа, чтобы это сделать! 

А чтобы это сделать, нужно пользоваться следующей конструкцией:

(тип данных)* (название переменной) = &(переменная, адрес которой хотим сохранить, желательно того же типа);

Например:

int n = 47;
int* p;
*p = &n;

Можно было записать и короче:

int n = 47;
int* p = &n;

И в том, и в другом случаях мы сохранили адрес переменной n в переменную p, т.е. теперь p = 00000000006AFD4C и этим значением можно оперировать.
Ещё хочется сказать, что операция * также служит операцией разыменовывания. 
Что это значит? - это означает, что если мы имеем адрес некоторой переменной, то мы можем узнать, какое значение лежит по этому адресу.
Из приведённых выше примеров, знаем, что в переменной p хранится адрес переменной n. Создадим некоторую переменную m, в которую впоследствии запишем
значение переменной n (т.е 47). Приведём пример кода:

int n = 47, m;
int* p;
m = *p; 

В результате выполнения кода в переменную m будет записано значение n. Это всё в результате операции разыменовывания *.
Визуально это можно представить так:

p = &n (в p записан адрес переменной)
m = *p = *(&n) = (*&)n = n; // фактически *& "взаимоуничтожают" друг друга.

В результате выполнения следующей программы:

int n = 47, m;
int* p = &n;
m = *p;
printf ("n = %d, adress of n = %p, unadress = %d", n, p, m);

OUTPUT: n = 47, adress of n = 00000000006AFD40, unadress = 47

2. МАССИВЫ И УКАЗАТЕЛИ

Рассмотрим следующий фрагмент кода:

int arr[5] = {1, 3, 5, 4, 2}; 
int *pt, *pr; 
pt = &arr[0];
pr = arr;
printf ("arr[0] adress = %p, arr adress = %p", pt, pr);

OUTPUT: arr[0] adress = 00000000006AFD20, arr adress = 00000000006AFD20

Пояснение:
arr - массив, состоящий из 5 элементов.
pt, pr - указатели.
pt = &arr[0] - запись в указатель адреса первого элемента массива.
pr = arr - даёт тот же результат, как можно заметить после выполнения кода. Мы будем использовать для удобства второй вариант записи адреса первого элемента 
массива (т.е. pr = arr), ведь выглядит это солиднее. 

pr = arr назовем указателем на масиив arr.

